import{_ as e,c as r,a4 as t,o as i}from"./chunks/framework.su6J3y5l.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"arch/ddia/replication.md","filePath":"arch/ddia/replication.md","lastUpdated":1732976097000}'),o={name:"arch/ddia/replication.md"};function s(l,a,n,p,c,d){return i(),r("div",null,a[0]||(a[0]=[t(`<p>复制 vs 分区</p><p>数据分布在多个节点上有两种常见的方式：</p><pre><code>复制（Replication）

在几个不同的节点上保存数据的相同副本，可能放在不同的位置。复制提供了冗余：如果一些节点不可用，剩余的节点仍然可以提供数据服务。复制也有助于改善性能。第五章 将讨论复制。

分区 (Partitioning)

将一个大型数据库拆分成较小的子集（称为 分区，即 partitions），从而不同的分区可以指派给不同的 节点（nodes，亦称 分片，即 sharding）。第六章 将讨论分区。
</code></pre><p>如果复制中的数据不会随时间而改变，那复制就很简单：将数据复制到每个节点一次就万事大吉。复制的困难之处在于处理复制数据的 变更（change），这就是本章所要讲的。我们将讨论三种流行的变更复制算法：单领导者（single leader，单主），多领导者（multi leader，多主） 和 无领导者（leaderless，无主）。几乎所有分布式数据库都使用这三种方法之一。</p><h2 id="领导者与追随者" tabindex="-1">领导者与追随者 <a class="header-anchor" href="#领导者与追随者" aria-label="Permalink to &quot;领导者与追随者&quot;">​</a></h2><p>基于领导者的复制（leader-based replication） （也称（active/passive），（master/slave）</p><p>其中一个副本被指定为 领导者（leader），也称为 主库（master|primary） 。当客户端要向数据库写入时，它必须将请求发送给该 领导者，其会将新数据写入其本地存储。 其他副本被称为 追随者（followers），亦称为 只读副本（read replicas）、从库（slaves）、备库（ secondaries） 或 热备（hot-standby</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>其中一个副本被指定为 领导者（leader），也称为 主库（master|primary） 。当客户端要向数据库写入时，它必须将请求发送给该 领导者，其会将新数据写入其本地存储。 其他副本被称为 追随者（followers），亦称为 只读副本（read replicas）、从库（slaves）、备库（ secondaries） 或 热备（hot-standby</p></div><h2 id="同步复制与异步复制" tabindex="-1">同步复制与异步复制 <a class="header-anchor" href="#同步复制与异步复制" aria-label="Permalink to &quot;同步复制与异步复制&quot;">​</a></h2><p>同步复制的优点是，从库能保证有与主库一致的最新数据副本。如果主库突然失效，我们可以确信这些数据仍然能在从库上找到。缺点是，如果同步从库没有响应（比如它已经崩溃，或者出现网络故障，或其它任何原因），主库就无法处理写入操作。主库必须阻止所有写入，并等待同步副本再次可用</p><p>如果在数据库上启用同步复制，通常意味着其中 一个 从库是同步的，而其他的从库则是异步的。如果该同步从库变得不可用或缓慢，则将一个异步从库改为同步运行。这保证你至少在两个节点上拥有最新的数据副本：主库和同步从库。这种配置有时也被称为 半同步（semi-synchronous）</p><div class="info custom-block"><p class="custom-block-title">关于复制的研究</p><p>对于异步复制系统而言，主库故障时会丢失数据可能是一个严重的问题，因此研究人员仍在研究不丢数据但仍能提供良好性能和可用性的复制方法。例如，链式复制（chain replication）【8,9】是同步复制的一种变体，已经在一些系统（如 Microsoft Azure Storage【10,11】）中成功实现。</p><p>复制的一致性与 共识（consensus，使几个节点就某个值达成一致）之间有着密切的联系，第九章 将详细地探讨这一领域的理论。本章主要讨论实践中的数据库常用的简单复制形式。</p></div><h2 id="处理节点宕机" tabindex="-1">处理节点宕机 <a class="header-anchor" href="#处理节点宕机" aria-label="Permalink to &quot;处理节点宕机&quot;">​</a></h2><p>系统中的任何节点都可能宕机，可能因为意外的故障，也可能由于计划内的维护（例如，重启机器以安装内核安全补丁）。对运维而言，能在系统不中断服务的情况下重启单个节点好处多多。我们的目标是，即使个别节点失效，也能保持整个系统运行，并尽可能控制节点停机带来的影响。</p><p>如何通过基于领导者的复制实现高可用？</p><h3 id="从库失效-追赶恢复" tabindex="-1">从库失效：追赶恢复 <a class="header-anchor" href="#从库失效-追赶恢复" aria-label="Permalink to &quot;从库失效：追赶恢复&quot;">​</a></h3><p>在其本地磁盘上，每个从库记录从主库收到的数据变更。如果从库崩溃并重新启动，或者，如果主库和从库之间的网络暂时中断，则比较容易恢复：从库可以从日志中知道，在发生故障之前处理的最后一个事务。因此，从库可以连接到主库，并请求在从库断开期间发生的所有数据变更。当应用完所有这些变更后，它就赶上了主库，并可以像以前一样继续接收数据变更流。</p><h3 id="主库失效-故障切换" tabindex="-1">主库失效：故障切换 <a class="header-anchor" href="#主库失效-故障切换" aria-label="Permalink to &quot;主库失效：故障切换&quot;">​</a></h3><p>主库失效处理起来相当棘手：其中一个从库需要被提升为新的主库，需要重新配置客户端，以将它们的写操作发送给新的主库，其他从库需要开始拉取来自新主库的数据变更。这个过程被称为 故障切换（failover）。</p><p>1.停电，网络暂时中断。没有万无一失的方法来检测出现了什么问题，所以大多数系统只是简单使用 超时（Timeout） 2.选择一个新的主库,控制器节点（controller node） 来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库（以最小化数据损失） 3.重新配置系统以启用新的主库。客户端现在需要将它们的写请求发送给新主库</p><p>临时的负载峰值可能导致节点的响应时间增加到超出超时时间，或者网络故障也可能导致数据包延迟。</p><h2 id="复制日志的实现" tabindex="-1">复制日志的实现 <a class="header-anchor" href="#复制日志的实现" aria-label="Permalink to &quot;复制日志的实现&quot;">​</a></h2><p>基于领导者的复制在底层是如何工作的？实践中有好几种不同的复制方式，所以先简要地看一下。 基于语句的复制</p><p>在最简单的情况下，主库记录下它执行的每个写入请求（语句，即 statement）并将该语句日志发送给从库。对于关系数据库来说，这意味着每个 INSERT、UPDATE 或 DELETE 语句都被转发给每个从库，每个从库解析并执行该 SQL 语句，就像直接从客户端收到一样。</p><p>任何调用 非确定性函数（nondeterministic） 的语句，可能会在每个副本上生成不同的值。例如，使用 NOW() 获取当前日期时间，或使用 RAND() 获取一个随机数。 主库可以用固定的返回值替换掉任何不确定的函数调用，以便所有从库都能获得相同的值</p>`,25)]))}const u=e(o,[["render",s]]);export{m as __pageData,u as default};
